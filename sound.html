<script>
  /* ========= BASIC DATA ========= */
  let beatWidth = 48;            // pixels per beat (zoomed)
  let isPlaying = false;
  let playheadPos = 0;           // current beat position
  let playTimer = null;
  
  const GRID_BEATS = 32;
  const tracks = [];
  const clips = [];
  
  let nextTrackId = 1;
  let nextClipId = 1;

  // DOM Elements
  const trackListEl = document.getElementById('track-list');
  const rulerInner = document.getElementById('ruler-inner');
  const gridInner = document.getElementById('grid-inner');
  const timelineScroll = document.getElementById('timeline-scroll');
  const zoomRange = document.getElementById('zoom-range');
  const playheadEl = document.getElementById('playhead');
  const addTrackBtn = document.getElementById('add-track-btn');
  const tempoValue = document.getElementById('tempo-value');

  /* ========= INIT ========= */
  function init() {
    buildRuler();
    // Add some default tracks
    addTrack('Drums (Kick/Snare)');
    addTrack('Bass Line (808)');
    addTrack('Melody (Synth)');
    addTrack('Vocals (Main)');
    
    // Add some default clips
    createClip(1, 0, 4, 'Kick Loop', 'blue');
    createClip(1, 4, 4, 'Kick Loop', 'blue');
    createClip(2, 0, 8, 'Sub Bass', 'purple');
    createClip(3, 2, 6, 'Arp Melody', 'green');
    createClip(4, 4, 8, 'Verse Vocal', 'pink');
  }

  /* ========= RULER ========= */
  function buildRuler() {
    rulerInner.innerHTML = '';
    // We create markers every beat
    for (let i = 1; i <= GRID_BEATS; i++) {
      const span = document.createElement('span');
      span.textContent = i;
      // ensure the width matches the zoom
      span.style.width = beatWidth + 'px';
      span.style.display = 'inline-block';
      rulerInner.appendChild(span);
    }
    // Update CSS variable for grid background
    gridInner.style.setProperty('--beat-width', beatWidth + 'px');
    rulerInner.style.gap = '0'; 
  }

  /* ========= TRACKS ========= */
  function addTrack(name) {
    const id = nextTrackId++;
    tracks.push({ id, name: name || `Track ${id}`, height: 40 });
    renderTracks();
    return id;
  }

  function renderTracks() {
    // Clean up existing
    const headers = Array.from(trackListEl.querySelectorAll('.track-header, .track-resize-handle'));
    headers.forEach(h => {
        if(!h.classList.contains('add-track-bar')) h.remove();
    });

    const rows = Array.from(gridInner.querySelectorAll('.grid-track-row'));
    rows.forEach(r => r.remove());

    tracks.forEach(t => {
      // 1. Left Header
      const header = document.createElement('div');
      header.className = 'track-header';
      header.style.height = t.height + 'px';

      const dot = document.createElement('div');
      dot.className = 'track-color-dot';

      const nameEl = document.createElement('div');
      nameEl.className = 'track-name';
      nameEl.textContent = t.name;
      
      // Editable name logic
      nameEl.addEventListener('dblclick', () => {
        nameEl.contentEditable = 'true';
        nameEl.focus();
      });
      nameEl.addEventListener('blur', () => {
        nameEl.contentEditable = 'false';
        t.name = nameEl.textContent;
      });

      const controls = document.createElement('div');
      controls.className = 'track-controls';
      
      ['M', 'S'].forEach(btnTxt => {
          const btn = document.createElement('button');
          btn.className = 'track-btn';
          btn.textContent = btnTxt;
          btn.onclick = () => btn.classList.toggle('active');
          controls.appendChild(btn);
      });

      header.append(dot, nameEl, controls);

      // Insert before the "Add Track" button
      const addBar = trackListEl.querySelector('.add-track-bar');
      trackListEl.insertBefore(header, addBar);

      // 2. Grid Row
      const gridRow = document.createElement('div');
      gridRow.className = 'grid-track-row';
      gridRow.dataset.trackId = t.id;
      gridRow.style.height = t.height + 'px';
      
      // Handle dropping clips onto this row (basic logic)
      gridRow.addEventListener('dragover', (e) => e.preventDefault());
      
      gridInner.appendChild(gridRow);
    });
    
    renderClips();
  }

  addTrackBtn.addEventListener('click', () => addTrack());

  /* ========= CLIPS ========= */
  function createClip(trackId, startBeat, lengthBeats, label, color) {
    const id = nextClipId++;
    clips.push({ id, trackId, startBeat, lengthBeats, label, color });
    renderClips();
  }

  function renderClips() {
    // Remove existing DOM clips
    document.querySelectorAll('.clip').forEach(c => c.remove());

    clips.forEach(clip => {
      // Find the row
      const row = gridInner.querySelector(`.grid-track-row[data-track-id="${clip.trackId}"]`);
      if (!row) return;

      const el = document.createElement('div');
      el.className = 'clip';
      el.dataset.id = clip.id;
      el.dataset.color = clip.color;
      
      // Position & Size
      el.style.left = (clip.startBeat * beatWidth) + 'px';
      el.style.width = (clip.lengthBeats * beatWidth) + 'px';
      
      // Inner Content
      el.innerHTML = `
        <div class="clip-handle-left"></div>
        <div class="clip-label">${clip.label}</div>
        <div class="clip-handle-right"></div>
      `;

      // Add Drag Logic
      initClipDrag(el, clip);

      row.appendChild(el);
    });
  }

  /* ========= INTERACTION: DRAG & DROP ========= */
  function initClipDrag(el, clipModel) {
    let startX = 0;
    let initialLeft = 0;
    let isDragging = false;

    el.addEventListener('mousedown', (e) => {
      e.stopPropagation(); // prevent conflict
      isDragging = true;
      startX = e.clientX;
      initialLeft = parseInt(el.style.left || 0);
      el.style.zIndex = 100;
      el.style.opacity = 0.8;
      
      // Global listeners for move/up
      const onMove = (moveEvent) => {
        if (!isDragging) return;
        const deltaX = moveEvent.clientX - startX;
        el.style.left = (initialLeft + deltaX) + 'px';
      };

      const onUp = (upEvent) => {
        isDragging = false;
        el.style.zIndex = '';
        el.style.opacity = '';
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);

        // Snap to grid logic
        const currentLeft = parseInt(el.style.left || 0);
        const rawBeats = currentLeft / beatWidth;
        let newStart = Math.round(rawBeats);
        if (newStart < 0) newStart = 0;
        
        // Determine which track (Y axis) - Simplified for demo:
        // We calculate the row based on mouse Y position relative to grid container
        const gridRect = gridInner.getBoundingClientRect();
        const relativeY = upEvent.clientY - gridRect.top + gridInner.scrollTop;
        
        // Find track index
        let trackIndex = Math.floor(relativeY / 40); // 40 is track height
        if (trackIndex < 0) trackIndex = 0;
        if (trackIndex >= tracks.length) trackIndex = tracks.length - 1;
        
        const newTrackId = tracks[trackIndex].id;

        // Update Model
        clipModel.startBeat = newStart;
        clipModel.trackId = newTrackId;
        
        // Re-render to snap visually
        renderClips();
      };

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    });
  }

  /* ========= ZOOM & TEMPO ========= */
  zoomRange.addEventListener('input', (e) => {
    beatWidth = parseInt(e.target.value);
    buildRuler();
    renderClips();
  });

  /* ========= TRANSPORT & PLAYBACK ========= */
  const btnPlay = document.getElementById('btn-play');
  const btnStop = document.getElementById('btn-stop');
  const btnRec = document.getElementById('btn-rec');
  
  function togglePlay() {
    if (isPlaying) {
        stopPlay();
    } else {
        startPlay();
    }
  }

  function startPlay() {
    isPlaying = true;
    btnPlay.classList.add('active');
    btnPlay.textContent = '⏸';
    
    // Simple loop
    const tempo = parseFloat(tempoValue.textContent);
    const msPerBeat = (60000 / tempo); 
    const fps = 60;
    const beatPerFrame = (1 / (msPerBeat / (1000/fps)));

    playTimer = setInterval(() => {
        playheadPos += 0.05; // approximate speed
        if (playheadPos > GRID_BEATS) playheadPos = 0;
        updatePlayhead();
    }, 1000/60);
  }

  function stopPlay() {
    isPlaying = false;
    btnPlay.classList.remove('active');
    btnPlay.textContent = '▶';
    clearInterval(playTimer);
  }

  function updatePlayhead() {
    const px = playheadPos * beatWidth;
    playheadEl.style.left = px + 'px';
    
    // Auto-scroll if playhead moves off screen
    const scrollLeft = timelineScroll.scrollLeft;
    const containerWidth = timelineScroll.clientWidth;
    if (px > scrollLeft + containerWidth - 50) {
        timelineScroll.scrollLeft = px - 50;
    }
  }

  btnPlay.addEventListener('click', togglePlay);
  btnStop.addEventListener('click', () => {
    stopPlay();
    playheadPos = 0;
    updatePlayhead();
  });
  btnRec.addEventListener('click', () => {
      btnRec.classList.toggle('active');
  });

  /* ========= UI PANELS TOGGLING ========= */
  // Logic to hide/show Browser, Rack, Mixer etc
  const dockIcons = document.querySelectorAll('.dock-icon');
  const panels = document.querySelectorAll('.dock-panel'); // left/center/right
  const bottomPanels = document.querySelectorAll('.bottom-panel');
  const bottomTabs = document.querySelectorAll('.bottom-tab');

  dockIcons.forEach(icon => {
    icon.addEventListener('click', () => {
        const target = icon.dataset.panel;
        icon.classList.toggle('active');
        
        // Mapping logic for Top Icons
        if (target === 'browser') {
            const p = document.querySelector('.left-browser');
            p.style.display = p.style.display === 'none' ? 'flex' : 'none';
        }
        if (target === 'plugins') {
            const p = document.querySelector('.right-placeholder');
            p.style.display = p.style.display === 'none' ? 'block' : 'none';
        }
        if (target === 'mixer') {
            document.querySelector('.bottom-dock').style.display = 
                document.querySelector('.bottom-dock').style.display === 'none' ? 'flex' : 'none';
        }
    });
  });

  // Bottom Tabs Switcher
  bottomTabs.forEach(tab => {
      tab.addEventListener('click', () => {
          // deactivate all
          bottomTabs.forEach(t => t.classList.remove('active'));
          bottomPanels.forEach(p => p.classList.remove('active'));
          
          // activate click
          tab.classList.add('active');
          const targetId = 'bottom-' + tab.dataset.bottomPanel;
          document.getElementById(targetId).classList.add('active');
      });
  });

  // Initialize
  init();

</script>
</body>
</html>
