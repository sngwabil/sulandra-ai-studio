<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sulandra SOUND – DAW Core</title>
    <style>
        body {
            background-color: #181818;
            color: #ccc;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            overflow: hidden;
            user-select: none;
        }

        /* TOP TRANSPORT + SECTION BAR */
        #top-bar {
            height: 40px;
            background-color: #202020;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding: 0 10px;
            gap: 8px;
        }

        .btn {
            background-color: #444;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 6px 10px;
            font-size: 12px;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
        }

        .btn:hover { background-color: #555; }
        .btn.icon {
            width: 30px;
            height: 26px;
            padding: 0;
        }

        .btn.active {
            background-color: #d9534f;
        }

        #section-buttons {
            display: flex;
            gap: 6px;
            margin-left: 12px;
        }

        #status-labels {
            margin-left: auto;
            font-size: 12px;
            display: flex;
            gap: 14px;
            align-items: center;
        }

        /* 4-SCREEN DISPLAY STRIP */
        #display-strip-wrapper {
            background-color: #101010;
            border-bottom: 1px solid #333;
            padding: 8px 12px;
        }

        #display-strip {
            max-width: 900px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }

        .display-cell {
            background-color: #000;
            border-radius: 6px;
            padding: 6px 10px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            box-shadow: 0 0 0 1px #333 inset;
            min-height: 40px;
        }

        .display-label {
            font-size: 10px;
            text-transform: uppercase;
            color: #888;
            margin-bottom: 2px;
        }

        .display-value {
            font-size: 13px;
        }

        #mix-display {
            transition: box-shadow 0.1s, color 0.1s;
        }

        /* WORKSPACE SPLIT: TRACK LIST + TIMELINE + BOTTOM MIXER */
        #workspace {
            position: absolute;
            top: 40px + 56px; /* overwritten in JS using calc, keep for clarity */
        }

        #workspace {
            top: 96px; /* 40 top bar + ~56 display */
            left: 0;
            right: 0;
            bottom: 0;
            position: absolute;
            display: flex;
            flex-direction: column;
        }

        #timeline-row {
            flex: 1;
            display: flex;
            min-height: 150px;
            overflow: hidden;
        }

        #track-list {
            width: 140px;
            background-color: #202020;
            border-right: 1px solid #333;
            padding-top: 30px; /* align with ruler */
            box-sizing: border-box;
        }

        .track-label {
            height: 100px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
            padding-left: 8px;
            font-size: 11px;
        }

        #timeline-container {
            position: relative;
            flex: 1;
            background-color: #181818;
            overflow: hidden;
        }

        #dawCanvas {
            display: block;
        }

        #timeline-help {
            position: absolute;
            bottom: 8px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            padding: 8px;
            font-size: 10px;
            pointer-events: none;
        }

        /* BOTTOM RESIZABLE MIXER PANEL */
        #bottom-panel {
            height: 220px;
            min-height: 40px;
            background-color: #161616;
            border-top: 1px solid #333;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        #bottom-resize-handle {
            height: 6px;
            cursor: ns-resize;
            background: #2a2a2a;
        }

        #bottom-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .bottom-section {
            flex: 1;
            display: none;
        }

        .bottom-section.active {
            display: flex;
        }

        /* simple mixer visual placeholder */
        #mixer-panel {
            padding: 10px;
            gap: 8px;
            overflow-x: auto;
        }

        .mixer-strip {
            width: 40px;
            background: #111;
            border-radius: 4px;
            box-shadow: 0 0 0 1px #333 inset;
            margin-right: 6px;
            padding: 6px 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 9px;
        }

        .mixer-fader {
            width: 10px;
            height: 80px;
            background: linear-gradient(to top, #222, #555);
            border-radius: 4px;
            margin: 4px 0;
            position: relative;
            overflow: hidden;
        }

        .mixer-fader-thumb {
            position: absolute;
            left: 0;
            right: 0;
            height: 10px;
            background: #f0ad4e;
            border-radius: 4px;
            top: 50%;
            transform: translateY(-50%);
        }

        /* prevent text selection while dragging bottom handle */
        .noselect {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body class="noselect">

<div id="top-bar">
    <!-- Transport -->
    <button id="btnPlay" class="btn">▶</button>
    <button id="btnStop" class="btn">■</button>
    <button id="btnExport" class="btn">Export WAV</button>

    <!-- Section toggles -->
    <div id="section-buttons">
        <button class="btn icon active" id="btnTimeline" title="Timeline">T</button>
        <button class="btn icon" id="btnMixer" title="Mixer">M</button>
        <button class="btn icon" id="btnRack" title="Channel Rack">R</button>
        <button class="btn icon" id="btnPiano" title="Piano Roll">P</button>
    </div>

    <div id="status-labels">
        <span>BPM: <span id="bpmLabel">120</span></span>
        <span>Playhead: <span id="playheadLabel">00:00.000</span></span>
    </div>
</div>

<!-- 4 DISPLAY SCREENS -->
<div id="display-strip-wrapper">
    <div id="display-strip">
        <div class="display-cell">
            <div class="display-label">Time</div>
            <div class="display-value" id="display-time">00:00.000</div>
        </div>
        <div class="display-cell">
            <div class="display-label">Key</div>
            <div class="display-value" id="display-key">Auto Detect</div>
        </div>
        <div class="display-cell">
            <div class="display-label">BPM</div>
            <div class="display-value" id="display-bpm">120</div>
        </div>
        <div class="display-cell" id="mix-display">
            <div class="display-label">Mix Level</div>
            <div class="display-value" id="display-mix">-∞ dB</div>
        </div>
    </div>
</div>

<!-- WORKSPACE -->
<div id="workspace">
    <div id="timeline-row">
        <!-- Track labels (simple mirror of clips' trackIndex for now) -->
        <div id="track-list">
            <div class="track-label">Track 1</div>
            <div class="track-label">Track 2</div>
            <div class="track-label">Track 3</div>
            <div class="track-label">Track 4</div>
        </div>

        <!-- Canvas timeline -->
        <div id="timeline-container">
            <canvas id="dawCanvas"></canvas>
            <div id="timeline-help">
                Scroll: Zoom • Shift+Scroll: Pan<br>
                Drag clip to move • Drag edge to resize<br>
                Drag white dots: automation points
            </div>
        </div>
    </div>

    <!-- Bottom mixer / rack / piano roll (resizable) -->
    <div id="bottom-panel">
        <div id="bottom-resize-handle"></div>
        <div id="bottom-content">
            <div id="mixer-panel" class="bottom-section active">
                <!-- simple 8 strips mirroring timeline tracks -->
                <div class="mixer-strip">
                    <div>Master</div>
                    <div class="mixer-fader"><div class="mixer-fader-thumb"></div></div>
                </div>
                <div class="mixer-strip">
                    <div>Ch 1</div>
                    <div class="mixer-fader"><div class="mixer-fader-thumb"></div></div>
                </div>
                <div class="mixer-strip">
                    <div>Ch 2</div>
                    <div class="mixer-fader"><div class="mixer-fader-thumb"></div></div>
                </div>
                <div class="mixer-strip">
                    <div>Ch 3</div>
                    <div class="mixer-fader"><div class="mixer-fader-thumb"></div></div>
                </div>
                <div class="mixer-strip">
                    <div>Ch 4</div>
                    <div class="mixer-fader"><div class="mixer-fader-thumb"></div></div>
                </div>
            </div>

            <div id="rack-panel" class="bottom-section">
                <!-- placeholder for channel rack UI -->
            </div>
            <div id="piano-panel" class="bottom-section">
                <!-- placeholder for piano roll UI -->
            </div>
        </div>
    </div>
</div>

<script>
/**
 * ============================================================
 * 1. DATA + STATE (JS port of your C++ structures)
 * ============================================================
 */
const CONFIG = {
    bpm: 120,
    sampleRate: 44100,
    trackHeight: 100,
    handleWidth: 10
};

const VIEW = {
    scrollX: 0,
    zoomX: 100,
    width: 0,
    height: 0
};

const STATE = {
    isPlaying: false,
    playheadTime: 0.0,
    lastFrameTime: 0,
    dragMode: 'NONE', // NONE, MOVE_CLIP, RESIZE_L, RESIZE_R, MOVE_AUTO
    activeClip: null,
    activePointIndex: -1,
    dragStartMouseX: 0,
    dragStartMouseY: 0,
    originalTime: 0,
    originalDuration: 0,
    cursor: 'default',
    meterLevel: 0 // 0..1
};

const PROJECT = {
    clips: [],
    bpm: CONFIG.bpm,
    sampleRate: CONFIG.sampleRate,
    totalLength: 16.0
};

function updateProjectLength() {
    let maxEnd = 0;
    PROJECT.clips.forEach(c => {
        const end = c.startTime + c.duration;
        if (end > maxEnd) maxEnd = end;
    });
    PROJECT.totalLength = Math.max(maxEnd, 4);
}

// Dummy sine clips (procedural audio)
function createDummyClip(start, duration, track, freq) {
    const totalSamples = Math.floor(duration * CONFIG.sampleRate);
    const buffer = new Float32Array(totalSamples);

    for (let i = 0; i < totalSamples; i++) {
        const t = i / CONFIG.sampleRate;
        buffer[i] = Math.sin(2 * Math.PI * freq * t) * 0.5;
    }

    return {
        startTime: start,
        duration: duration,
        offset: 0.0,
        trackIndex: track,
        buffer: buffer,
        sampleRate: CONFIG.sampleRate,
        name: `Sine ${freq}Hz`,
        isSelected: false,
        automation: [
            { time: start, value: 0.5 },
            { time: start + duration, value: 0.5 }
        ]
    };
}

PROJECT.clips.push(createDummyClip(0.0, 4.0, 0, 440));
PROJECT.clips.push(createDummyClip(4.0, 4.0, 1, 261.6));
updateProjectLength();

/**
 * ============================================================
 * 2. AUDIO ENGINE + EXPORT (JS AudioEngine/WAVExporter)
 * ============================================================
 */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let activeNodes = [];

function getAutomationValueAtTime(clip, time) {
    const pts = clip.automation || [];
    if (pts.length === 0) return 1.0;
    if (time <= pts[0].time) return pts[0].value;
    if (time >= pts[pts.length - 1].time) return pts[pts.length - 1].value;

    for (let i = 0; i < pts.length - 1; i++) {
        const a = pts[i];
        const b = pts[i + 1];
        if (time >= a.time && time < b.time) {
            const t = (time - a.time) / (b.time - a.time);
            return a.value + t * (b.value - a.value);
        }
    }
    return 1.0;
}

const AudioEngine = {
    processBlock(project, outBuffer, numSamples, startTime) {
        const sr = project.sampleRate;
        const secondsPerSample = 1.0 / sr;

        for (let i = 0; i < numSamples; i++) outBuffer[i] = 0.0;

        for (let i = 0; i < numSamples; i++) {
            const currentTime = startTime + i * secondsPerSample;
            let mixedSample = 0.0;

            for (const clip of project.clips) {
                if (currentTime >= clip.startTime && currentTime < clip.startTime + clip.duration) {
                    const localTime = (currentTime - clip.startTime) + (clip.offset || 0);
                    const sampleIdx = Math.floor(localTime * clip.sampleRate);
                    if (sampleIdx >= 0 && sampleIdx < clip.buffer.length) {
                        const vol = getAutomationValueAtTime(clip, currentTime);
                        mixedSample += clip.buffer[sampleIdx] * vol;
                    }
                }
            }

            if (mixedSample > 1.0) mixedSample = 1.0;
            if (mixedSample < -1.0) mixedSample = -1.0;

            outBuffer[i] = mixedSample;
        }
    }
};

function playAudio() {
    if (STATE.isPlaying) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    STATE.isPlaying = true;
    STATE.lastFrameTime = performance.now();
    activeNodes = [];

    PROJECT.clips.forEach(clip => {
        if (clip.startTime + clip.duration > STATE.playheadTime) {
            const source = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(1, clip.buffer.length, CONFIG.sampleRate);
            buffer.copyToChannel(clip.buffer, 0);
            source.buffer = buffer;

            const gainNode = audioCtx.createGain();
            gainNode.gain.value = getAutomationValueAtTime(
                clip,
                Math.max(STATE.playheadTime, clip.startTime)
            );

            source.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            let when = audioCtx.currentTime + (clip.startTime - STATE.playheadTime);
            let offset = 0;

            if (STATE.playheadTime > clip.startTime) {
                when = audioCtx.currentTime;
                offset = STATE.playheadTime - clip.startTime;
            }

            if (when >= audioCtx.currentTime) {
                source.start(when, offset);
                activeNodes.push(source);
            }
        }
    });
}

function stopAudio() {
    STATE.isPlaying = false;
    activeNodes.forEach(n => n.stop());
    activeNodes = [];
}

// compute meter from playhead position
function computeMeterLevel(t) {
    let mixed = 0.0;
    for (const clip of PROJECT.clips) {
        if (t >= clip.startTime && t < clip.startTime + clip.duration) {
            const localTime = (t - clip.startTime) + (clip.offset || 0);
            const idx = Math.floor(localTime * clip.sampleRate);
            if (idx >= 0 && idx < clip.buffer.length) {
                const vol = getAutomationValueAtTime(clip, t);
                mixed += clip.buffer[idx] * vol;
            }
        }
    }
    mixed = Math.max(-1, Math.min(1, mixed));
    return Math.abs(mixed); // 0..1
}

// WAV export (block renderer)
function exportWAV() {
    updateProjectLength();

    const sr = PROJECT.sampleRate;
    const duration = PROJECT.totalLength;
    const totalSamples = Math.floor(duration * sr);
    const blockSize = 1024;

    const floatBlock = new Float32Array(blockSize);
    const buffer = new ArrayBuffer(44 + totalSamples * 2);
    const view = new DataView(buffer);

    const writeString = (offset, str) => {
        for (let i = 0; i < str.length; i++) {
            view.setUint8(offset + i, str.charCodeAt(i));
        }
    };

    writeString(0, 'RIFF');
    view.setUint32(4, 36 + totalSamples * 2, true);
    writeString(8, 'WAVE');
    writeString(12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sr, true);
    view.setUint32(28, sr * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(36, 'data');
    view.setUint32(40, totalSamples * 2, true);

    let renderHead = 0;
    let byteOffset = 44;

    while (renderHead < duration) {
        const remaining = totalSamples - Math.floor(renderHead * sr);
        const thisBlock = Math.min(blockSize, remaining);

        AudioEngine.processBlock(PROJECT, floatBlock, thisBlock, renderHead);

        for (let i = 0; i < thisBlock; i++) {
            let s = floatBlock[i];
            if (s > 1.0) s = 1.0;
            if (s < -1.0) s = -1.0;
            const int16 = s < 0 ? s * 0x8000 : s * 0x7FFF;
            view.setInt16(byteOffset + i * 2, int16, true);
        }

        byteOffset += thisBlock * 2;
        renderHead += thisBlock / sr;
    }

    const blob = new Blob([buffer], { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'Sulandra_Track.wav';
    a.click();
}

/**
 * ============================================================
 * 3. VIEW ENGINE (canvas)
 * ============================================================
 */
const canvas = document.getElementById('dawCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    const rect = document.getElementById('timeline-container').getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    VIEW.width = canvas.width;
    VIEW.height = canvas.height;
    draw();
}
window.addEventListener('resize', resizeCanvas);

const timeToPx = t => (t - VIEW.scrollX) * VIEW.zoomX;
const pxToTime = p => (p / VIEW.zoomX) + VIEW.scrollX;
const trackToPy = idx => (idx * CONFIG.trackHeight) + 30;
const valToPy = (val, trackIdx) =>
    trackToPy(trackIdx) + CONFIG.trackHeight - (val * CONFIG.trackHeight);
const pyToVal = (y, trackIdx) =>
    1.0 - ((y - trackToPy(trackIdx)) / CONFIG.trackHeight);

function draw() {
    ctx.fillStyle = '#1e1e1e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // ruler
    ctx.fillStyle = '#2d2d2d';
    ctx.fillRect(0, 0, canvas.width, 30);
    ctx.fillStyle = '#fff';
    ctx.font = '11px Arial';
    ctx.fillText('Timeline', 10, 18);

    // grid
    const beatInterval = 60 / PROJECT.bpm;
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 1;
    ctx.fillStyle = '#aaa';
    ctx.font = '10px Arial';

    const startBeat = Math.floor(VIEW.scrollX / beatInterval);
    const endBeat = Math.ceil(pxToTime(VIEW.width) / beatInterval);

    for (let i = startBeat; i <= endBeat; i++) {
        const time = i * beatInterval;
        const x = timeToPx(time);

        ctx.beginPath();
        ctx.moveTo(x, 30);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();

        if (x >= 0 && x <= canvas.width) {
            ctx.fillText((i + 1).toString(), x + 2, 20);
        }
    }

    // clips
    PROJECT.clips.forEach(clip => {
        const x = timeToPx(clip.startTime);
        const w = clip.duration * VIEW.zoomX;
        const y = trackToPy(clip.trackIndex);
        const h = CONFIG.trackHeight;

        if (x + w < 0 || x > canvas.width) return;

        ctx.fillStyle = clip.isSelected ? '#d9534f' : '#f0ad4e';
        ctx.fillRect(x, y + 2, w, h - 4);

        ctx.fillStyle = '#000';
        ctx.font = '11px Arial';
        ctx.fillText(clip.name, x + 5, y + 15);

        if (clip.automation && clip.automation.length > 0) {
            ctx.strokeStyle = 'rgba(255,255,255,0.9)';
            ctx.lineWidth = 2;
            ctx.beginPath();

            clip.automation.forEach((pt, idx) => {
                const px = timeToPx(pt.time);
                const py = valToPy(pt.value, clip.trackIndex);
                if (idx === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            ctx.fillStyle = '#fff';
            clip.automation.forEach(pt => {
                const px = timeToPx(pt.time);
                const py = valToPy(pt.value, clip.trackIndex);
                ctx.beginPath();
                ctx.arc(px, py, 4, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        if (clip.isSelected) {
            ctx.fillStyle = 'rgba(255,255,255,0.3)';
            ctx.fillRect(x, y + 2, CONFIG.handleWidth, h - 4);
            ctx.fillRect(x + w - CONFIG.handleWidth, y + 2, CONFIG.handleWidth, h - 4);
        }
    });

    // playhead
    const phX = timeToPx(STATE.playheadTime);
    if (phX >= 0 && phX <= canvas.width) {
        ctx.strokeStyle = '#0f0';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(phX, 0);
        ctx.lineTo(phX, canvas.height);
        ctx.stroke();

        ctx.fillStyle = '#0f0';
        ctx.beginPath();
        ctx.moveTo(phX - 6, 0);
        ctx.lineTo(phX + 6, 0);
        ctx.lineTo(phX, 10);
        ctx.fill();
    }

    canvas.style.cursor = STATE.cursor;
}

/**
 * ============================================================
 * 4. INPUT (mouse / wheel)
 * ============================================================
 */
function snapTime(t) {
    const beat = 60 / PROJECT.bpm;
    const snapped = Math.round(t / beat) * beat;
    return Math.abs(t - snapped) < 0.2 ? snapped : t;
}

canvas.addEventListener('mousedown', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const mTime = pxToTime(mx);

    // automation points
    for (const c of PROJECT.clips) {
        if (!c.automation) continue;
        for (let i = 0; i < c.automation.length; i++) {
            const pt = c.automation[i];
            const px = timeToPx(pt.time);
            const py = valToPy(pt.value, c.trackIndex);
            const dist = Math.hypot(mx - px, my - py);
            if (dist < 8) {
                STATE.dragMode = 'MOVE_AUTO';
                STATE.activeClip = c;
                STATE.activePointIndex = i;
                return;
            }
        }
    }

    let clickedClip = null;
    for (const c of PROJECT.clips) {
        const x = timeToPx(c.startTime);
        const w = c.duration * VIEW.zoomX;
        const y = trackToPy(c.trackIndex);
        if (mx >= x && mx <= x + w && my >= y && my <= y + CONFIG.trackHeight) {
            clickedClip = c;
            break;
        }
    }

    PROJECT.clips.forEach(c => (c.isSelected = false));

    if (clickedClip) {
        const c = clickedClip;
        c.isSelected = true;
        STATE.activeClip = c;
        STATE.dragStartMouseX = mx;
        STATE.originalTime = c.startTime;
        STATE.originalDuration = c.duration;

        const x = timeToPx(c.startTime);
        const w = c.duration * VIEW.zoomX;

        if (mx < x + CONFIG.handleWidth) STATE.dragMode = 'RESIZE_L';
        else if (mx > x + w - CONFIG.handleWidth) STATE.dragMode = 'RESIZE_R';
        else STATE.dragMode = 'MOVE_CLIP';
        return;
    }

    if (my < 30) {
        STATE.playheadTime = mTime;
        return;
    }

    STATE.dragMode = 'NONE';
    STATE.activeClip = null;
});

canvas.addEventListener('mousemove', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const mTime = pxToTime(mx);
    const snappedTime = snapTime(mTime);

    if (STATE.dragMode !== 'NONE' && STATE.activeClip) {
        const clip = STATE.activeClip;
        if (STATE.dragMode === 'MOVE_CLIP') {
            const dt = pxToTime(mx) - pxToTime(STATE.dragStartMouseX);
            clip.startTime = snapTime(STATE.originalTime + dt);
            updateProjectLength();
        } else if (STATE.dragMode === 'RESIZE_R') {
            const newDur = snappedTime - clip.startTime;
            if (newDur > 0.1) clip.duration = newDur;
            updateProjectLength();
        } else if (STATE.dragMode === 'RESIZE_L') {
            const endTime = STATE.originalTime + STATE.originalDuration;
            const newStart = Math.min(snappedTime, endTime - 0.1);
            clip.startTime = newStart;
            clip.duration = endTime - newStart;
            updateProjectLength();
        } else if (STATE.dragMode === 'MOVE_AUTO') {
            const pt = clip.automation[STATE.activePointIndex];
            pt.time = Math.max(clip.startTime, Math.min(clip.startTime + clip.duration, mTime));
            pt.value = Math.max(0, Math.min(1, pyToVal(my, clip.trackIndex)));
        }
    } else {
        STATE.cursor = 'default';
        for (const c of PROJECT.clips) {
            const x = timeToPx(c.startTime);
            const w = c.duration * VIEW.zoomX;
            const y = trackToPy(c.trackIndex);
            if (mx >= x && mx <= x + w && my >= y && my <= y + CONFIG.trackHeight) {
                if (mx < x + CONFIG.handleWidth || mx > x + w - CONFIG.handleWidth) {
                    STATE.cursor = 'col-resize';
                } else {
                    STATE.cursor = 'move';
                }
            }
        }
    }
});

canvas.addEventListener('mouseup', () => {
    STATE.dragMode = 'NONE';
    STATE.activeClip = null;
    STATE.activePointIndex = -1;
});

// Zoom + pan
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    if (e.shiftKey) {
        VIEW.scrollX += e.deltaY > 0 ? 0.5 : -0.5;
        if (VIEW.scrollX < 0) VIEW.scrollX = 0;
    } else {
        const mouseTime = pxToTime(e.offsetX);
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        VIEW.zoomX *= factor;
        if (VIEW.zoomX < 10) VIEW.zoomX = 10;
        if (VIEW.zoomX > 500) VIEW.zoomX = 500;
        VIEW.scrollX = mouseTime - e.offsetX / VIEW.zoomX;
        if (VIEW.scrollX < 0) VIEW.scrollX = 0;
    }
});

/**
 * ============================================================
 * 5. UI WIRING (buttons, display, mixer dock)
 * ============================================================
 */
document.getElementById('btnPlay').onclick = playAudio;
document.getElementById('btnStop').onclick = () => {
    stopAudio();
    STATE.isPlaying = false;
};
document.getElementById('btnExport').onclick = exportWAV;

document.getElementById('bpmLabel').textContent = PROJECT.bpm.toString();
document.getElementById('display-bpm').textContent = PROJECT.bpm.toString();

// toggle bottom sections
function setBottomSection(sectionId) {
    document.querySelectorAll('.bottom-section').forEach(sec => {
        sec.classList.remove('active');
    });
    const sec = document.getElementById(sectionId);
    if (sec) sec.classList.add('active');
}

document.getElementById('btnMixer').onclick = () => {
    setBottomSection('mixer-panel');
};
document.getElementById('btnRack').onclick = () => {
    setBottomSection('rack-panel');
};
document.getElementById('btnPiano').onclick = () => {
    setBottomSection('piano-panel');
};

// resize bottom panel by dragging handle
(function () {
    const bottomPanel = document.getElementById('bottom-panel');
    const handle = document.getElementById('bottom-resize-handle');
    let isDragging = false;
    let startY = 0;
    let startHeight = 0;

    handle.addEventListener('mousedown', e => {
        isDragging = true;
        startY = e.clientY;
        startHeight = bottomPanel.getBoundingClientRect().height;
        document.body.classList.add('noselect');
    });

    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dy = e.clientY - startY;
        let newHeight = startHeight - dy;
        if (newHeight < 40) newHeight = 40;
        if (newHeight > window.innerHeight - 120) newHeight = window.innerHeight - 120;
        bottomPanel.style.height = newHeight + 'px';
        resizeCanvas();
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
        document.body.classList.remove('noselect');
    });
})();

/**
 * ============================================================
 * 6. MAIN LOOP – updates display + meter + canvas
 * ============================================================
 */
function formatTime(t) {
    if (t < 0) t = 0;
    const ms = Math.floor((t % 1) * 1000);
    const totalSeconds = Math.floor(t);
    const sec = totalSeconds % 60;
    const min = Math.floor(totalSeconds / 60);
    const pad = n => (n < 10 ? '0' + n : '' + n);
    const pad3 = n => (n < 10 ? '00' + n : n < 100 ? '0' + n : '' + n);
    return `${pad(min)}:${pad(sec)}.${pad3(ms)}`;
}

function updateDisplays() {
    const timeStr = formatTime(STATE.playheadTime);
    document.getElementById('playheadLabel').textContent = timeStr;
    document.getElementById('display-time').textContent = timeStr;

    if (STATE.isPlaying) {
        STATE.meterLevel = computeMeterLevel(STATE.playheadTime);
    } else {
        STATE.meterLevel *= 0.9; // quick falloff
    }

    const level = STATE.meterLevel;
    let db;
    if (level <= 0.0001) db = -Infinity;
    else db = 20 * Math.log10(level);

    const mixText = db === -Infinity ? '-∞ dB' : db.toFixed(1) + ' dB';
    const mixDisplay = document.getElementById('mix-display');
    document.getElementById('display-mix').textContent = mixText;

    let color = '#3498db'; // blue
    if (level > 0.8) color = '#e74c3c'; // red
    else if (level > 0.3) color = '#2ecc71'; // green
    mixDisplay.style.boxShadow = `0 0 0 1px ${color} inset`;
    mixDisplay.style.color = color;
}

function mainLoop() {
    const now = performance.now();
    const dt = (now - STATE.lastFrameTime) / 1000;
    STATE.lastFrameTime = now;

    if (STATE.isPlaying) {
        STATE.playheadTime += dt;
        const phX = timeToPx(STATE.playheadTime);
        if (phX > VIEW.width * 0.9) {
            VIEW.scrollX = STATE.playheadTime;
        }
    }

    updateDisplays();
    draw();
    requestAnimationFrame(mainLoop);
}

// init
resizeCanvas();
STATE.lastFrameTime = performance.now();
mainLoop();
</script>
</body>
</html>
